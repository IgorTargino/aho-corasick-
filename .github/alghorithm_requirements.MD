# **An√°lise de Consumo de Mem√≥ria para o Aut√¥mato Aho-Corasick em Sistemas Embarcados üíæ**

Este documento detalha o c√°lculo da mem√≥ria utilizada pela estrutura do aut√¥mato Aho-Corasick (ac\_automaton\_t) e a l√≥gica para o gerenciamento do or√ßamento de mem√≥ria, visando uma implementa√ß√£o eficiente em sistemas embarcados com restri√ß√£o de 8KB.

## **Explica√ß√£o do C√°lculo de Mem√≥ria para ac\_automaton\_t**

A f√≥rmula para estimar o tamanho total da estrutura ac\_automaton\_t √©:  
**Total \= (AC\_MAX\_VERTICES \* 229\) \+ (AC\_MAX\_PATTERNS \* 4\) \+ 20 bytes**  
Vamos entender cada componente dessa f√≥rmula:

### **1\. Mem√≥ria dos V√©rtices (AC\_MAX\_VERTICES \* 225 bytes)**

A principal parte da mem√≥ria √© consumida pelo array trie\_automaton\_nodes, que armazena os v√©rtices (ou n√≥s) do aut√¥mato.

* **AC\_MAX\_VERTICES**: Constante que define o n√∫mero m√°ximo de v√©rtices.  
* **225 bytes**: Tamanho de cada v√©rtice (ac\_vertex\_t). Este valor √© derivado da soma dos seus campos internos, considerando sizeof(int)=4 bytes, sizeof(bool)=1 byte, AC\_K\_ALPHABET\_SIZE=26 (para 'a'-'z') e AC\_MAX\_PATTERNS\_PER\_NODE=2:  
  * next\[26\] (transi√ß√µes diretas da Trie): 26 \* 4 \= 104 bytes  
  * go\[26\] (transi√ß√µes do aut√¥mato, incluindo falhas): 26 \* 4 \= 104 bytes  
  * link (link de falha): 1 \* 4 \= 4 bytes  
  * output (flag booleana): 1 byte  
  * pattern\_indices\[2\] (√≠ndices de padr√µes que terminam no n√≥): 2 \* 4 \= 8 bytes  
  * num\_patterns\_at\_node (contador de padr√µes no n√≥): 1 \* 4 \= 4 bytes  
  * **Total por ac\_vertex\_t**: 104 \+ 104 \+ 4 \+ 1 \+ 8 \+ 4 \= 225 bytes.

### **2\. Mem√≥ria para Ponteiros de Padr√µes (AC\_MAX\_PATTERNS \* 4 bytes)**

A estrutura ac\_automaton\_t armazena um array de ponteiros (const char\*) chamado patterns, que aponta para as strings dos padr√µes adicionados.

* **AC\_MAX\_PATTERNS**: Constante que define o n√∫mero m√°ximo de padr√µes.  
* **4 bytes**: Tamanho de cada ponteiro (considerando um sistema de 32 bits).

### **3\. Mem√≥ria da Fila Auxiliar (AC\_MAX\_VERTICES \* 4 \+ 12 bytes)**

Para a constru√ß√£o dos links de falha, √© utilizada uma fila (aho\_queue\_t) que est√° embutida na estrutura ac\_automaton\_t.

* **queue\[AC\_MAX\_VERTICES\]**: Array de inteiros para os √≠ndices dos n√≥s, consumindo AC\_MAX\_VERTICES \* 4 bytes.  
* **head, tail, count**: Tr√™s vari√°veis inteiras para controle da fila, consumindo 3 \* 4 \= 12 bytes.

### **4\. Mem√≥ria para Outros Campos (8 bytes)**

Dois campos inteiros adicionais na estrutura ac\_automaton\_t:

* current\_nodes\_count (contador de n√≥s utilizados): 4 bytes  
* num\_total\_patterns (contador total de padr√µes): 4 bytes

### **Agrega√ß√£o da F√≥rmula**

Somando todos os componentes:

* Mem√≥ria dos n√≥s: AC\_MAX\_VERTICES \* 225  
* Mem√≥ria dos ponteiros de padr√µes: AC\_MAX\_PATTERNS \* 4  
* Mem√≥ria do array da fila: AC\_MAX\_VERTICES \* 4  
* Mem√≥ria dos controles da fila: 12  
* Mem√≥ria de outros campos: 8

Agrupando termos semelhantes:

* Termos com AC\_MAX\_VERTICES: (AC\_MAX\_VERTICES \* 225\) \+ (AC\_MAX\_VERTICES \* 4\) \= AC\_MAX\_VERTICES \* (225 \+ 4\) \= AC\_MAX\_VERTICES \* 229\.  
* Constantes: 12 \+ 8 \= 20\.

Resultando na f√≥rmula final: **(AC\_MAX\_VERTICES \* 229\) \+ (AC\_MAX\_PATTERNS \* 4\) \+ 20 bytes**.

## **L√≥gica para o Or√ßamento de Mem√≥ria (Budget) üéØ**

O desafio principal √© operar dentro de um **limite estrito de 8KB (8192 bytes)** para toda a mem√≥ria est√°tica relevante da aplica√ß√£o. A estrat√©gia adotada √©:

1. **Definir Or√ßamento Total**: **8192 bytes**.  
2. **Alocar Buffers Essenciais de Tamanho Fixo**:  
   * **Buffer de Texto de Entrada**: Espa√ßo para o texto que ser√° analisado.  
   * **Buffer de Prop√≥sito Geral Pequeno**: Uma reserva de mem√≥ria para outras funcionalidades que a aplica√ß√£o embarcada possa necessitar (ex: configura√ß√µes, flags, pequenos buffers de comunica√ß√£o). Este buffer simula a realidade de sistemas embarcados, onde a mem√≥ria √© compartilhada por diversas tarefas.  
3. **Calcular Mem√≥ria Dispon√≠vel para o Aut√¥mato**: Subtrair o tamanho dos buffers fixos do or√ßamento total.  
   * Com um buffer de texto de 512 bytes e um buffer geral de 256 bytes:  
     Mem√≥ria Restante \= 8192 \- 512 \- 256 \= 7424 bytes.  
4. **Ajustar Configura√ß√µes do Aut√¥mato (aho\_config.h)**:  
   * Os valores de AC\_MAX\_VERTICES e AC\_MAX\_PATTERNS s√£o ent√£o dimensionados para que o ac\_automaton\_t caiba nos 7424 bytes dispon√≠veis.  
   * A equa√ß√£o (AC\_MAX\_VERTICES \* 229\) \+ (AC\_MAX\_PATTERNS \* 4\) \+ 20 \<= 7424 deve ser satisfeita.  
   * Simplificando: (AC\_MAX\_VERTICES \* 229\) \+ (AC\_MAX\_PATTERNS \* 4\) \<= 7404\.

### **Dimensionamento do Aut√¥mato:**

* Mantendo AC\_MAX\_VERTICES \= 30:  
  * 30 \* 229 \= 6870 bytes (consumidos pelos v√©rtices e parte da fila).  
  * Restam para os ponteiros de padr√µes (AC\_MAX\_PATTERNS \* 4): 7404 \- 6870 \= 534 bytes.  
  * Logo, AC\_MAX\_PATTERNS \<= 534 / 4 \= 133.5.  
* Para manter uma propor√ß√£o razo√°vel e permitir um bom n√∫mero de padr√µes, define-se AC\_MAX\_PATTERNS \= 30\.

Com AC\_MAX\_VERTICES \= 30 e AC\_MAX\_PATTERNS \= 30:  
Tamanho do Aut√¥mato \= (30 \* 229\) \+ (30 \* 4\) \+ 20 \= 6870 \+ 120 \+ 20 \= 7010 bytes.

### **Verifica√ß√£o Final do Or√ßamento:**

* Buffer de Texto: **512 bytes**  
* Buffer de Prop√≥sito Geral: **256 bytes**  
* Aut√¥mato Aho-Corasick: **7010 bytes**  
* **Uso Total Estimado**: 512 \+ 256 \+ 7010 \= 7778 bytes.

Este valor de 7778 bytes est√° confortavelmente abaixo do limite de 8192 bytes, deixando 8192 \- 7778 \= 414 bytes de margem para a pilha de execu√ß√£o (stack), vari√°veis locais e outras pequenas aloca√ß√µes do sistema. üéâ